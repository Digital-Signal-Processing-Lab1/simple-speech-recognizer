# -*- coding:utf-8 -*-

import sys
# 注意在本机需要添加系统默认路径
sys.path.append("./")
#from sklearn import svm
import sklearn.utils as su
from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import train_test_split
from sklearn.model_selection import cross_val_score
from sklearn.decomposition import PCA
from librosa.feature import mfcc
import sklearn.metrics as sm
import scipy.signal as signal
import os
import VAD
import utils
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

N, M = 256, 128
# np.random.seed(24)
file_path = "../dataset/processed/"

def padding_zeros_to(data: pd.Series, length):
    ret = data.copy()
    for i in range(len(ret)):
        t = np.array(data[i]).reshape(-1)
        ret[i] = np.concatenate([t, np.zeros(length-t.shape[0])], axis=0)
    return ret


def padding_to_max(data: pd.Series):
    max_length = np.max([len(w) for w in data.energy])
    data.energy = padding_zeros_to(data.energy, max_length)
    data.amplitude = padding_zeros_to(data.amplitude, max_length)
    data.zerocrossingrate = padding_zeros_to(data.zerocrossingrate, max_length)
    return data, max_length

def get_mfcc_features(wave_data: pd.Series, n_mfcc):
    """
    mfcc_feature
    """
    x = wave_data.apply(lambda d: (d-np.mean(d))/(np.std(d)))
    # x = wave_data
    x, max_length = utils.padding_to_max(x)
    features = []
    for i in range(x.shape[0]):
        t1 = mfcc(x[i], sr=16000, n_mfcc=n_mfcc)
        t2 = utils.diff(t1, axis=0)
        t3 = utils.diff(t1, axis=0, delta=2)
        t = np.concatenate([t1.T, t2.T, t3.T], axis=1).flatten()
        features.append(t)
    return np.array(features)

def plot_classify_result(label, real, predict, filename):
    plt.figure(figsize=(8, 6))
    n_label = len(label)
    m = np.zeros([n_label, n_label])
    for r, p in zip(real, predict):
        m[int(r), int(p)] += 1
    plt.imshow(m)
    plt.xticks(label)
    plt.yticks(label)
    plt.xlabel("predict")
    plt.ylabel("real")
    plt.colorbar()
    plt.tight_layout()
    plt.savefig(filename, dpi=200)

for window_type in ["rect", "hamming", "hanning"]:
    if window_type == 'rect':
        winfunc = 1
    elif window_type == 'hamming':
        winfunc = signal.windows.hamming(N)
    else:
        winfunc = signal.windows.hann(N)
    print("training with window of {}...".format(window_type))

    path = os.path.join(file_path, "{}.pkl".format(window_type))
    df = utils.load_pkl(path)
    # 去除噪声数据集
    # df = df[df["has_noisy"] == False]
    # df = df.reset_index()
    wave_data = df.wave_data
    label = df.content

    # 特征提取
    mfcc_f = get_mfcc_features(wave_data, 40)

    # 开始降维
    # mfcc_f 为特征向量
    pca = PCA(n_components=11)
    pca.fit(mfcc_f)
    mfcc_f = pca.transform(mfcc_f)

    # 开始训练
    #使用KNN分类器识别语音信号，
    x, y = su.shuffle(mfcc_f, np.array(label).astype(np.int).reshape(-1, 1), random_state=40)
    X_train, X_test, y_train, y_test = train_test_split(x, y, random_state=40, train_size=0.66, test_size=0.34)
    #knn = KNeighborsClassifier(n_neighbors=3)
    #knn.fit(X_train,y_train.ravel())

#使用10折交叉验证,求出使得KNN算法性能最好的K值
    #scores = cross_val_score(knn, X_train,y_train.ravel(), cv=10, scoring='accuracy')
    k_range = range(1,31)
    k_scores = []
    for k in k_range:
        knn_t = KNeighborsClassifier(n_neighbors=k)
        scores = cross_val_score(knn_t, X_train, y_train.ravel(), cv=10, scoring='accuracy')
        k_scores.append(scores.mean())
    print("cross-validation average scores for different 'k':",k_scores)
    best_k = 1
    best_score = 0
    for m in range(29):
        if k_scores[m] > best_score:
            best_score = k_scores[m]
            best_k = m+1
    print("best 'k' for knn:",best_k)
#KNN算法采用用计算所得的最佳K值
    #knn_best = KNeighborsClassifier(n_neighbors=best_k)
    knn_best = KNeighborsClassifier(n_neighbors=3)       #neighbors值选3，避免过拟合
    knn_best.fit(X_train,y_train.ravel())
    print("train accuracy :",knn_best.score(X_train,y_train))
    print("test  accuracy :",knn_best.score(X_test,y_test))
    print("best cross-validation average score:",best_score)

    test = y_test.reshape(1, -1).flatten()
    predict = knn_best.predict(X_test)
    r2 = sm.r2_score(test, predict)
    print("r2 score :", r2)
    print("f1 score :", sm.f1_score(test, predict, average=None))
    print("plotting data...")
    plot_classify_result(range(10), test, predict, "../mfcc_knn_classifier/KNN_result_"+window_type+".png")

    print("done")
